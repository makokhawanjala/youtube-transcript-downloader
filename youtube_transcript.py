# -*- coding: utf-8 -*-
"""youtube_transcript.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TmcnmWBQDg1GKFGI6R3XR-dpA4n5zXgA

# YouTube Transcript Downloader

## Project Requirements

The client needed a Google Colab program to collect YouTube video transcripts and combine them into a single text file with two input methods:

**Channel-Based Selection:**
- Enter a YouTube channel
- Download all videos or filter by publication date

**Search-Based Selection:**
- Enter a search term
- Select specific videos or download all results

**Output Format:**
Each video transcript must follow this exact structure:

++++++++++++++[Video Title | Publish Date]
(transcript text)
==============END=================


(blank line)

**Critical Requirements:**
- Zero or minimal setup required
- Keep costs as low as possible
- Explain what's needed before running
- Clarify runtime expectations and limitations

## My Solution

I developed a complete system that requires absolutely no API keys, no registration, and no authentication. The solution runs entirely on free libraries with unlimited usage.

**What I Delivered:**

I built an interactive program with clean separation of concerns across eight modular components. The system handles both channel and search inputs, provides flexible video selection including ranges and individual picks, implements comprehensive error handling, and produces professionally formatted output files.

**Setup Requirements:**

Nothing. I designed this to work immediately in Google Colab without any preliminary configuration. The program automatically installs required libraries when you run it.
"""

# Setup and Installation
"""
YouTube Transcript Downloader
A tool to download and combine YouTube video transcripts into a single text file.
Supports channel-based and search-based video selection.
"""

try:
    import subprocess
    import sys

    # Install required library
    result = subprocess.run(
        [sys.executable, "-m", "pip", "install", "-q", "youtube-transcript-api", "yt-dlp"],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        raise Exception(f"Installation failed: {result.stderr}")

    # Import libraries
    from youtube_transcript_api import YouTubeTranscriptApi
    import datetime
    import re

    print("Setup complete! Ready to use.")

except Exception as e:
    print(f"Installation failed: {e}")
    print("Please try running the cell again.")

# Helper Functions
def extract_video_id(url):
    """Extract YouTube video ID from various URL formats."""
    if not url or not isinstance(url, str):
        return None

    url = url.strip()

    # Try different URL patterns
    patterns = [
        r'(?:youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})',
        r'(?:youtu\.be\/)([a-zA-Z0-9_-]{11})',
        r'(?:youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})',
        r'(?:youtube\.com\/v\/)([a-zA-Z0-9_-]{11})',
        r'(?:youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})'
    ]

    for pattern in patterns:
        match = re.search(pattern, url)
        if match:
            return match.group(1)

    # Check if already a video ID
    if re.match(r'^[a-zA-Z0-9_-]{11}$', url):
        return url

    return None


def extract_channel_id(url_or_handle):
    """Extract YouTube channel identifier from URL or handle."""
    if not url_or_handle or not isinstance(url_or_handle, str):
        return None

    url_or_handle = url_or_handle.strip()

    # Try different channel URL patterns
    patterns = [
        (r'youtube\.com\/channel\/([a-zA-Z0-9_-]+)', lambda m: m.group(1)),
        (r'youtube\.com\/c\/([a-zA-Z0-9_-]+)', lambda m: m.group(1)),
        (r'youtube\.com\/user\/([a-zA-Z0-9_-]+)', lambda m: m.group(1)),
        (r'youtube\.com\/@([a-zA-Z0-9_-]+)', lambda m: '@' + m.group(1))
    ]

    for pattern, processor in patterns:
        match = re.search(pattern, url_or_handle)
        if match:
            return processor(match)

    # Handle direct @handle input
    if url_or_handle.startswith('@'):
        return url_or_handle

    return url_or_handle

# Channel Video Fetching
def get_channel_videos(channel_input, date_filter=None):
    """
    Fetch video metadata from a YouTube channel.

    Args:
        channel_input: Channel URL, @handle, or channel ID
        date_filter: Optional date string "YYYY-MM-DD" to filter videos

    Returns:
        List of video dictionaries with {video_id, title, publish_date}
    """
    print(f"Fetching videos from channel: {channel_input}")

    channel_id = extract_channel_id(channel_input)
    if not channel_id:
        print("Error: Invalid channel input")
        return []

    # Validate date filter
    filter_date = None
    if date_filter:
        try:
            filter_date = datetime.datetime.strptime(date_filter, "%Y-%m-%d")
            print(f"Filtering videos from: {date_filter}")
        except ValueError:
            print("Error: Invalid date format. Use YYYY-MM-DD")
            return []

    try:
        import yt_dlp

        print("Fetching videos...")

        # Build channel URL
        if channel_id.startswith('@'):
            channel_url = f"https://www.youtube.com/{channel_id}/videos"
        elif channel_id.startswith('UC'):
            channel_url = f"https://www.youtube.com/channel/{channel_id}/videos"
        else:
            channel_url = f"https://www.youtube.com/c/{channel_id}/videos"

        # Configure yt-dlp
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extract_flat': True,
            'playlistend': 1000,
        }

        videos = []

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            try:
                result = ydl.extract_info(channel_url, download=False)

                if 'entries' in result:
                    for entry in result['entries']:
                        if entry:
                            video_id = entry.get('id')
                            title = entry.get('title', 'Unknown Title')
                            upload_date = entry.get('upload_date', 'Unknown')

                            # Format date
                            if upload_date != 'Unknown' and len(upload_date) == 8:
                                upload_date = f"{upload_date[:4]}-{upload_date[4:6]}-{upload_date[6:]}"

                            # Apply date filter
                            if filter_date and upload_date != 'Unknown':
                                try:
                                    video_date = datetime.datetime.strptime(upload_date, "%Y-%m-%d")
                                    if video_date < filter_date:
                                        continue
                                except:
                                    pass

                            if video_id:
                                videos.append({
                                    'video_id': video_id,
                                    'title': title,
                                    'publish_date': upload_date
                                })

            except Exception as e:
                print(f"Error: {str(e)}")
                return []

        print(f"Found {len(videos)} videos")
        return videos

    except Exception as e:
        print(f"Error fetching videos: {str(e)}")
        return []

# Search Video Fetching
def search_youtube_videos(search_term, max_results=50):
    """
    Search for YouTube videos by search term.

    Args:
        search_term: Search query string
        max_results: Maximum number of results (default: 50)

    Returns:
        List of video dictionaries with {video_id, title, channel, publish_date}
    """
    if not search_term or not isinstance(search_term, str):
        print("Error: Invalid search term")
        return []

    search_term = search_term.strip()
    if not search_term:
        print("Error: Search term cannot be empty")
        return []

    print(f"Searching for: '{search_term}'")

    try:
        import yt_dlp

        print("Searching...")

        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extract_flat': True,
            'default_search': 'ytsearch',
        }

        videos = []
        search_query = f"ytsearch{max_results}:{search_term}"

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            try:
                result = ydl.extract_info(search_query, download=False)

                if 'entries' in result:
                    for entry in result['entries']:
                        if entry:
                            video_id = entry.get('id')
                            title = entry.get('title', 'Unknown Title')
                            channel = entry.get('channel', 'Unknown Channel')
                            upload_date = entry.get('upload_date', 'Unknown')

                            # Format date
                            if upload_date != 'Unknown' and len(upload_date) == 8:
                                upload_date = f"{upload_date[:4]}-{upload_date[4:6]}-{upload_date[6:]}"

                            if video_id:
                                videos.append({
                                    'video_id': video_id,
                                    'title': title,
                                    'channel': channel,
                                    'publish_date': upload_date
                                })

            except Exception as e:
                print(f"Error: {str(e)}")
                return []

        print(f"Found {len(videos)} results")
        return videos

    except Exception as e:
        print(f"Error searching: {str(e)}")
        return []

# Transcript Download
def download_transcript(video_id):
    """
    Download transcript for a single video.

    Args:
        video_id: YouTube video ID

    Returns:
        Dictionary with transcript data and status
    """
    try:
        ytt_api = YouTubeTranscriptApi()
        fetched_transcript = ytt_api.fetch(video_id, languages=['en'])

        # Combine transcript snippets
        transcript_text = " ".join(snippet.text for snippet in fetched_transcript)

        return {
            'video_id': video_id,
            'title': f"Video {video_id}",
            'transcript_text': transcript_text.strip(),
            'publish_date': "Unknown",
            'success': True,
            'error_message': None
        }

    except Exception as e:
        error_msg = str(e)

        # Simplify common errors
        if "No transcript" in error_msg or "Subtitles are disabled" in error_msg:
            error_msg = "No transcript available"
        elif "private" in error_msg.lower():
            error_msg = "Video is private"
        elif "unavailable" in error_msg.lower() or "deleted" in error_msg.lower():
            error_msg = "Video unavailable"

        return {
            'video_id': video_id,
            'title': 'Unknown',
            'transcript_text': '',
            'publish_date': 'Unknown',
            'success': False,
            'error_message': error_msg
        }

# Batch Processing
def process_and_save_transcripts(video_list, output_filename):
    """
    Process multiple videos and save transcripts to file.

    Args:
        video_list: List of video dictionaries
        output_filename: Output file name
    """
    if not video_list:
        print("Error: No videos to process")
        return

    total_videos = len(video_list)
    successful = 0
    failed = []

    print(f"\nProcessing {total_videos} videos...")
    print("="*60)

    try:
        with open(output_filename, 'w', encoding='utf-8') as f:
            for index, video in enumerate(video_list, 1):
                video_id = video.get('video_id')
                video_title = video.get('title', 'Unknown Title')
                video_date = video.get('publish_date', 'Unknown')

                print(f"\n[{index}/{total_videos}] {video_title[:60]}...")

                result = download_transcript(video_id)

                if result['success']:
                    final_title = video_title if video_title != 'Unknown Title' else result['title']
                    final_date = video_date if video_date != 'Unknown' else result['publish_date']

                    # Write in required format
                    f.write(f"++++++++++++++[{final_title} | {final_date}]\n")
                    f.write(result['transcript_text'])
                    f.write("\n==============END=================\n\n\n")

                    successful += 1
                    print(f"Success ({len(result['transcript_text'])} characters)")
                else:
                    failed.append({
                        'title': video_title,
                        'video_id': video_id,
                        'error': result['error_message']
                    })
                    print(f"Failed: {result['error_message']}")

        # Summary
        print("\n" + "="*60)
        print("COMPLETE")
        print("="*60)
        print(f"Success: {successful} | Failed: {len(failed)}")

        if failed:
            print("\nFailed videos:")
            for i, fail in enumerate(failed, 1):
                print(f"{i}. {fail['title'][:50]} - {fail['error']}")

        print(f"\nSaved to: {output_filename}")

    except Exception as e:
        print(f"Error: {str(e)}")

# CELL 7: Main Interface
def main():
    """Main interactive interface."""
    print("\n" + "="*60)
    print("YOUTUBE TRANSCRIPT DOWNLOADER")
    print("="*60)

    print("\nChoose input method:")
    print("  1. Channel URL (all videos or by date)")
    print("  2. Search term")

    choice = input("\nEnter choice (1 or 2): ").strip()
    videos = []

    # Channel mode
    if choice == '1':
        print("\n" + "-"*60)
        print("CHANNEL MODE")
        print("-"*60)

        channel_input = input("\nEnter channel URL or @handle: ").strip()
        if not channel_input:
            print("Error: Channel input required")
            return

        filter_choice = input("\nFilter by date? (Y/N): ").strip().upper()
        date_filter = None
        if filter_choice == 'Y':
            date_filter = input("Enter date (YYYY-MM-DD): ").strip()

        print()
        videos = get_channel_videos(channel_input, date_filter)

        if not videos:
            print("\nNo videos found.")
            return

        print(f"\nFound {len(videos)} videos.")
        download_all = input("Download all? (Y/N): ").strip().upper()

        if download_all != 'Y':
            print("\n" + "-"*60)
            print("VIDEO LIST:")
            print("-"*60)
            for i, video in enumerate(videos, 1):
                print(f"{i}. {video['title'][:70]}")
                print(f"   Published: {video['publish_date']}")

            print("\nEnter video numbers to download")
            selection = input("(e.g., '1,3,5-8' or 'all'): ").strip()

            if selection.lower() != 'all':
                selected_indices = set()
                try:
                    for part in selection.split(','):
                        part = part.strip()
                        if '-' in part:
                            start, end = part.split('-')
                            selected_indices.update(range(int(start.strip()), int(end.strip()) + 1))
                        else:
                            selected_indices.add(int(part))

                    videos = [videos[i-1] for i in sorted(selected_indices) if 0 < i <= len(videos)]

                    if not videos:
                        print("\nNo valid selection.")
                        return

                    print(f"\nSelected {len(videos)} videos")
                except Exception as e:
                    print(f"\nError: {str(e)}")
                    return

    # Search mode
    elif choice == '2':
        print("\n" + "-"*60)
        print("SEARCH MODE")
        print("-"*60)

        search_term = input("\nEnter search term: ").strip()
        if not search_term:
            print("Error: Search term required")
            return

        print()
        videos = search_youtube_videos(search_term, max_results=50)

        if not videos:
            print("\nNo videos found.")
            return

        print("\n" + "-"*60)
        print("SEARCH RESULTS:")
        print("-"*60)
        for i, video in enumerate(videos, 1):
            print(f"{i}. {video['title'][:60]}")
            print(f"   Channel: {video['channel']}")
            print(f"   Published: {video['publish_date']}")

        print("\nEnter video numbers to download")
        selection = input("(e.g., '1,3,5-8' or 'all'): ").strip()

        if selection.lower() != 'all':
            selected_indices = set()
            try:
                for part in selection.split(','):
                    part = part.strip()
                    if '-' in part:
                        start, end = part.split('-')
                        selected_indices.update(range(int(start.strip()), int(end.strip()) + 1))
                    else:
                        selected_indices.add(int(part))

                videos = [videos[i-1] for i in sorted(selected_indices) if 0 < i <= len(videos)]

                if not videos:
                    print("\nNo valid selection.")
                    return

                print(f"\nSelected {len(videos)} videos")
            except Exception as e:
                print(f"\nError: {str(e)}")
                return

    else:
        print("\nInvalid choice.")
        return

    # Get output filename
    print("\n" + "-"*60)
    output_filename = input("\nOutput filename (default: transcripts_output.txt): ").strip()

    if not output_filename:
        output_filename = "transcripts_output.txt"

    if not output_filename.endswith('.txt'):
        output_filename += '.txt'

    # Process videos
    process_and_save_transcripts(videos, output_filename)

    print("\n" + "="*60)
    print(f"Done! File: {output_filename}")
    print("="*60)

# Run Program
try:
    main()
except KeyboardInterrupt:
    print("\n\nProgram interrupted.")
except Exception as e:
    print(f"\n\nError: {str(e)}")
    print("Please check your inputs and try again.")

"""## How to Use This Program

Let me walk you through using the system.

### Step One: Run All Cells

Go to Runtime in the menu and click Run all. The program will automatically install required libraries and prepare everything.

### Step Two: Choose Your Input Method

When prompted, you'll select between channel mode and search mode.

**If you choose Channel Mode:**
You'll enter a channel URL or handle like @ChannelName. The program asks if you want to filter by date. If yes, provide a date in YYYY-MM-DD format. Then decide whether to download all videos or select specific ones.

**If you choose Search Mode:**
You'll enter your search term. The program displays matching videos with numbers. You can then select specific videos using individual numbers, ranges like 5-10, or type 'all' to download everything.

### Step Three: Name Your Output File

The program asks for a filename. Press Enter to use the default name, or type your preferred name. The system automatically adds the .txt extension if you forget it.

### Step Four: Download Your File

Once processing completes, find your file in the Files panel on the left sidebar. Click the three dots next to the filename and select Download.

### Example Workflows

#### Workflow 1: Download Recent Channel Videos
```
Choice: 1 (Channel)
Input: @MomentumMastery572
Date Filter: Y
Date: 2024-12-01
Download All: Y
Filename: recent_videos.txt
```

#### Workflow 2: Search and Select Specific Videos
```
Choice: 2 (Search)
Search: "Alan Watts motivation"
Selection: 1,3,5-10
Filename: selected_transcripts.txt
```

### Output Format
I implemented the exact format specified:
```
++++++++++++++[Video Title | Publish Date]
Full transcript text here...
==============END=================


Next video...
```
"""